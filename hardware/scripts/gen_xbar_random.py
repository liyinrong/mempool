#!/usr/bin/env python3
# Copyright 2024 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

import argparse
import sys
import math
import random

license = """\
// Copyright 2025 ETH Zurich and University of Bologna.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
"""

script_path = "scripts/gen_xbar_random.py"

def gen_header(command):
    header = license
    header += '// Automatically generated by:\n'
    header += f'// {script_path} {command}\n'
    return header

def clog2(x):
    if x < 1:
        raise ValueError("clog2 is not defined for numbers less than 1")
    return math.ceil(math.log2(x))

def generate_crossbar(InNum, OutNum, seed=42):
    module_name = "mempool_tile_resp_select"

    # Inputs and outputs
    inputs = ["input  logic [InNum-1:0] req_vector_i"]
    inputs.append("input  logic [$clog2(InNum)-1:0] priority_i")
    outputs = [
        "output logic [OutNum-1:0][$clog2(InNum)-1:0] sel_inport_idx_o",
        "output logic [OutNum-1:0]                    sel_inport_idx_vld_o",
        "output logic [InNum-1:0][$clog2(OutNum)-1:0] asn_outport_idx_o",
        "output logic [InNum-1:0]                     asn_outport_vld_o"
    ]

    # Assertion
    assertion = (
        "initial begin\n"
        f"    assert (InNum == {InNum}) else "
        "$fatal(1, \n\"Parameter InNum does not "
        f"match expected value {InNum}\");\n"
        f"    assert (OutNum == {OutNum}) else "
        "$fatal(1, \n\"Parameter OutNum does not "
        f"match expected value {OutNum}\");\n"
        "end\n"
    )

    # Declaration
    declaration = (
        "logic [OutNum-1:0][$clog2(InNum)-1:0] sel_inport_idx_raw;\n"
        "logic [OutNum-1:0]                    sel_inport_idx_raw_vld;\n"
        "logic [InNum-1:0]                     req_vector_rotate;\n"
    )

    # Priority logic
    priority_logic = (
        "assign sel_inport_idx_vld_o = sel_inport_idx_raw_vld ;\n"
        "assign req_vector_rotate = (priority_i == '0) ? req_vector_i :\n"
        "                           "
        "((req_vector_i << (InNum -priority_i)) | "
        "(req_vector_i >> priority_i));\n"
    )

    # Output logic
    output_logic = (
        "\nalways_comb begin\n"
        "    for(int i = 0; i < OutNum; i++) begin\n"
        "        if(sel_inport_idx_raw[i] < (InNum - priority_i)) begin\n"
        "            sel_inport_idx_o[i] = sel_inport_idx_raw [i]\n"
        "                                + priority_i;\n"
        "        end else begin\n"
        "            sel_inport_idx_o[i] = sel_inport_idx_raw [i] - "
        "(InNum - priority_i);\n"
        "        end\n"
        "    end\n"
        "end\n"
        "\nalways_comb begin\n"
        "    asn_outport_idx_o = '0;\n"
        "    asn_outport_vld_o = '0;\n"
        "    for(int i = 0; i < OutNum; i++) begin\n"
        "        if(sel_inport_idx_raw_vld[i] == 1'b1) begin\n"
        "            asn_outport_idx_o[sel_inport_idx_o[i]] = i;\n"
        "            asn_outport_vld_o[sel_inport_idx_o[i]] = 1'b1;\n"
        "        end\n"
        "    end\n"
        "end\n"
    )

    # Switch-case generation with per-case randomness
    rng = random.Random(seed)
    switch_case = (
        "always_comb begin\n"
        "    sel_inport_idx_raw     = '0;\n"
        "    sel_inport_idx_raw_vld = '0;\n"
        "    case (req_vector_rotate)\n"
    )

    for i in range(2 ** InNum):
        case_str = bin(i)[2:].zfill(InNum)
        switch_case += f"        {InNum}'b{case_str}: begin\n"

        set_bits = [j for j in range(InNum) if case_str[InNum - 1 - j] == '1']
        if set_bits:
            output_priority_order = list(range(OutNum))
            rng.shuffle(output_priority_order)
            rng.shuffle(set_bits)

            for out_idx, in_idx in zip(output_priority_order, set_bits):
                switch_case += (
                    f"            sel_inport_idx_raw[{out_idx}] = {clog2(InNum)}'d{in_idx};\n"
                    f"            sel_inport_idx_raw_vld[{out_idx}] = 1'b1;\n"
                )

            for out_idx in output_priority_order[len(set_bits):]:
                switch_case += (
                    f"            sel_inport_idx_raw[{out_idx}] = {clog2(InNum)}'d0;\n"
                    f"            sel_inport_idx_raw_vld[{out_idx}] = 1'b0;\n"
                )
        else:
            for out_idx in range(OutNum):
                switch_case += (
                    f"            sel_inport_idx_raw[{out_idx}] = {clog2(InNum)}'d0;\n"
                    f"            sel_inport_idx_raw_vld[{out_idx}] = 1'b0;\n"
                )
        switch_case += "        end\n"
    switch_case += "        default: /*do nothing */;\n"
    switch_case += "    endcase\n"
    switch_case += "end\n"

    # Compose full module
    sv_code = f"module {module_name} #(\n"
    sv_code += f"    parameter int InNum = {InNum},\n"
    sv_code += f"    parameter int OutNum = {OutNum}\n"
    sv_code += ") (\n"
    sv_code += "    " + ",\n    ".join(inputs)
    sv_code += ",\n    " + ",\n    ".join(outputs)
    sv_code += "\n);\n\n"
    sv_code += assertion + "\n"
    sv_code += declaration + "\n"
    sv_code += priority_logic + "\n"
    sv_code += output_logic + "\n"
    sv_code += switch_case + "\n"
    sv_code += "endmodule\n"

    return sv_code

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-in', '--input_num', required=True, type=int)
    parser.add_argument('-on', '--output_num', required=True, type=int)
    parser.add_argument('-o', '--output', required=True, help='Output filename')
    parser.add_argument('--seed', type=int, default=0, help='Fixed seed for randomness')

    args = parser.parse_args()
    input_num = args.input_num
    output_num = args.output_num
    output_file = args.output
    seed = args.seed

    if output_num == 3:
        seed = 0
    elif output_num == 2:
        seed = 1

    sv_code = generate_crossbar(input_num, output_num, seed)

    with open(output_file, "w") as f:
        f.write(gen_header(' '.join(sys.argv[1:])))
        f.write(sv_code)

    print(f"Generated SystemVerilog module with InNum={input_num}, OutNum={output_num}, seed={seed}")
    print(f"Saved to: {output_file}")

if __name__ == "__main__":
    main()
